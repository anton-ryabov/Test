1. Какой системный вызов делает команда cd?

	* Решение: 
		* strace /bin/bash -c 'cd /tmp' 2>&1 | grep /tmp
		* execve("/bin/bash", ["/bin/bash", "-c", "cd /tmp"], 0x7fff3786ba60 /* 54 vars */) = 0
		* newfstatat(AT_FDCWD, "/tmp", {st_mode=S_IFDIR|S_ISVTX|0777, st_size=4096, ...}, 0) = 0
		* chdir("/tmp") = 0

2. Попробуйте использовать команду file на объекты разных типов в файловой системе. Используя strace выясните, где находится база данных file, на основании которой она делает свои догадки.

	* Решение: /usr/share/misc/magic.mgc

3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).

	* Решение: отправить пустую строчку echo "" > /proc/[PID]/fd/3

4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?

		* Решение: нет

5. В iovisor BCC есть утилита opensnoop:

	root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
	/usr/sbin/opensnoop-bpfcc
На какие файлы вы увидели вызовы группы open за первую секунду работы 		утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Д			ополнительные сведения по установке.

	* Решение:
	- PID    COMM               FD ERR PATH
	- 567    systemd-oomd        7   0 /proc/meminfo
 	- 567    systemd-oomd        7   0 /proc/meminfo
	- 567    systemd-oomd        7   0 /proc/meminfo
	- 567    systemd-oomd        7   0 /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/memory.pressure
	- 567    systemd-oomd        7   0 /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/memory.current
	- 567    systemd-oomd        7   0 /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/memory.min
	- 567    systemd-oomd        7   0 /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/memory.low
	- 567    systemd-oomd        7   0 /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/memory.swap.current
	- 567    systemd-oomd        7   0 /sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/memory.stat


6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.

	* Решение: 
		* Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.*
		* uname -a - выводит всю системную информцию {a - all}

7. Чем отличается последовательность команд через ; и через && в bash?. Есть ли смысл использовать в bash &&, если применить set -e?
	
	* Решение: 
		* ; - комманды выполняются последовательно не обращая внимания на ошибки
		* && - комманды выполняются последовательно, последывательность прирвется при ошибке.
		* "Exits immediately if a command exits with a non-zero exit status." - судя по цитате из ман смысл в && есть, дабы завершить последовательность при ошибке.

9. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?

	* Решение: 
	 	- e - Немедленно завершает работу, если команда завершается с ненулевым 	статусом выхода.
		- u - Рассматривает неустановленные переменные как ошибку при подстановке.
		- x - Выводит команды и их аргументы по мере их выполнения.
		- o - Если опция не указана, в стандартный вывод выводится список опций и их текущие настройки. При вызове с помощью + параметры записываются в формате, который можно снова ввести в оболочку для восстановления настроек. Этот параметр можно повторить, чтобы включить или отключить несколько параметров.
		- pipefail — конвейер не завершается до тех пор, пока не будут завершены все компоненты конвейера, а статус выхода конвейера — это значение последней команды для выхода с ненулевым статусом выхода или равно нулю, если все команды возвращают нулевой статус выхода.
	
	* В сценариях можно обноружить и исправить ошибки, неверные переменные и т.д. Для детализации и отладки. 

9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

	* Решение: 
		- root@vagrant:/home/vagrant# ps -o stat
		- STAT
		- S
		- S
		- S
		- R+
	- Чаще всего встречается S
